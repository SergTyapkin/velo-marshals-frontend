name: ${FRONTEND_COMPOSE_NAME:-frontend-compose}
services:
  # Base frontend container. When all certs generated any other nginx containers must be stopped
  nginx:
    container_name: ${FRONTEND_COMPOSE_NAME:-frontend-compose}-frontend-nginx
    build:
      context: ../
      dockerfile: ./docker-deploy/Dockerfile
      args:
        - NGINX_RELEASE
        - NODE_RELEASE
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certbot/www:/var/www/certbot/:ro
      - ./certbot/conf/:/etc/nginx/ssl/:ro
    ports:
      - '80:80'
      - '443:443'
      - '${API_PORT}:${API_PORT}'
      - '${API_MEDIA_PORT}:${API_MEDIA_PORT}'
    environment:
      - DOMAIN_URL=${VITE_DEPLOY_HOSTNAME}
      - API_PORT
      - API_HOST
      - API_MEDIA_PORT
      - API_MEDIA_HOST
    networks:
      - external-front-back
      - default
    restart: unless-stopped

  # Needs to serve only http and get certs when certs is not created yet
  nginx-certbot:
    container_name: ${FRONTEND_COMPOSE_NAME:-frontend-compose}-nginx-certbot
    image: nginx:${NGINX_RELEASE}
    volumes:
      - ./nginx/nginx_certbot.conf:/etc/nginx/nginx.conf:ro
      - ./certbot/www:/var/www/certbot/:ro
    ports:
      - '80:80'
    restart: no

  # To generate certs:
  # docker compose up -d nginx-certbot
  # docker compose run --rm certbot certonly --webroot --webroot-path /var/www/certbot/ -d your.domain
  # To renew certs:
  # docker compose run --rm certbot renew
  certbot:
    container_name: ${FRONTEND_COMPOSE_NAME:-frontend-compose}-certbot
    image: certbot/certbot:latest
    volumes:
      - ./certbot/www/:/var/www/certbot/:rw
      - ./certbot/conf/:/etc/letsencrypt/:rw
    restart: no

networks:
  external-front-back:
